using System.Text;
using Visor.Abstractions.Enums;
using Visor.CLI.Metadata;

namespace Visor.CLI.Generators;

public class CodeEmitter(string toolVersion)
{
    private static readonly HashSet<string> CSharpKeywords = new(StringComparer.Ordinal)
    {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
    };

    public string GenerateInterface(
        string interfaceName,
        string namespaceName,
        VisorProvider provider,
        List<ProcedureDefinition> procedureDefinitions)
    {
        var stringBuilder = new StringBuilder();

        stringBuilder.AppendLine("// <auto-generated>");
        stringBuilder.AppendLine($"//     This code was generated by Visor.CLI {toolVersion}.");
        stringBuilder.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        stringBuilder.AppendLine("//     the code is regenerated.");
        stringBuilder.AppendLine("// </auto-generated>");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("using System.CodeDom.Compiler;");
        stringBuilder.AppendLine("using Visor.Abstractions;");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"namespace {namespaceName};");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"[Visor(VisorProvider.{provider})]");
        stringBuilder.AppendLine($"[GeneratedCode(\"Visor.CLI\", \"{toolVersion}\")]");
        stringBuilder.AppendLine($"public interface {interfaceName}");
        stringBuilder.AppendLine("{");

        foreach (var procedureDefinition in procedureDefinitions)
        {
            EmitEndpoint(stringBuilder, procedureDefinition);
        }

        stringBuilder.AppendLine("}");

        return stringBuilder.ToString();
    }

    public string GenerateTableTypeClass(TableTypeDefinition tableTypeDefinition, string namespaceName)
    {
        var stringBuilder = new StringBuilder();
        var className = NormalizeClassName(tableTypeDefinition.Name);

        GenerateClassBody(stringBuilder, namespaceName, className, $"{tableTypeDefinition.Schema}.{tableTypeDefinition.Name}", tableTypeDefinition.Columns);

        return stringBuilder.ToString();
    }

    public string GenerateResultSetClass(ProcedureDefinition procedureDefinition, string namespaceName)
    {
        var stringBuilder = new StringBuilder();
        var className = $"{NormalizeClassName(procedureDefinition.Name)}Result";

        stringBuilder.AppendLine("// <auto-generated/>");
        stringBuilder.AppendLine($"namespace {namespaceName};");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("using Visor.Abstractions;");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"public class {className}");
        stringBuilder.AppendLine("{");

        if (procedureDefinition.ResultSet != null)
        {
            foreach (var column in procedureDefinition.ResultSet.Columns)
            {
                EmitProperty(stringBuilder, column);
            }
        }

        stringBuilder.AppendLine("}");
        return stringBuilder.ToString();
    }

    private void GenerateClassBody(StringBuilder stringBuilder, string namespaceName, string className, string databaseObjectName, List<ColumnDefinition> columns)
    {
        stringBuilder.AppendLine("// <auto-generated/>");
        stringBuilder.AppendLine($"namespace {namespaceName};");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("using Visor.Abstractions;");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"[VisorTable(\"{databaseObjectName}\")]");
        stringBuilder.AppendLine($"public class {className}");
        stringBuilder.AppendLine("{");

        foreach (var column in columns)
        {
            EmitProperty(stringBuilder, column);
        }

        stringBuilder.AppendLine("}");
    }

    private void EmitEndpoint(StringBuilder stringBuilder, ProcedureDefinition procedureDefinition)
    {
        var methodName = NormalizeMethodName(procedureDefinition.Name);
        var returnType = procedureDefinition.ResultSet == null
            ? "Task"
            : $"Task<List<{methodName}Result>>";

        stringBuilder.AppendLine($"    [Endpoint(\"{procedureDefinition.Schema}.{procedureDefinition.Name}\")]");
        stringBuilder.Append($"    {returnType} {methodName}Async(");

        var parameters = procedureDefinition.Parameters.Select(parameter =>
        {
            var csharpType = GetCSharpTypeName(parameter.DbType, parameter.IsNullable);

            if (!string.IsNullOrEmpty(parameter.UserDefinedTypeName))
            {
                var dtoName = NormalizeClassName(parameter.UserDefinedTypeName);
                csharpType = $"List<{dtoName}>";
            }
            else if (parameter.IsCollection)
            {
                // Primitive array support (e.g. List<int> for integer[])
                // GetCSharpTypeName returns "int?" or "int", we need "int" inside List
                var baseType = GetCSharpTypeName(parameter.DbType, false);
                csharpType = $"List<{baseType}>";
            }

            return $"{csharpType} {NormalizeParameterName(parameter.Name)}";
        });

        stringBuilder.Append(string.Join(", ", parameters));
        stringBuilder.AppendLine(");");
        stringBuilder.AppendLine();
    }

    private void EmitProperty(StringBuilder stringBuilder, ColumnDefinition columnDefinition)
    {
        var typeName = GetCSharpTypeName(columnDefinition.DbType, columnDefinition.IsNullable);
        var propertyName = NormalizePropertyName(columnDefinition.Name);

        stringBuilder.AppendLine($"    [VisorColumn({columnDefinition.Order}, VisorDbType.{columnDefinition.DbType}, Name = \"{columnDefinition.Name}\")]");
        stringBuilder.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
        stringBuilder.AppendLine();
    }

    public static string NormalizeMethodName(string databaseName)
    {
        var parts = databaseName.Split(['_', '.'], StringSplitOptions.RemoveEmptyEntries);
        var cleanParts = parts.Where(part => !part.Equals("sp", StringComparison.OrdinalIgnoreCase)).ToArray();
        var name = string.Join("", cleanParts.Select(ToPascalCase));
        return SanitizeIdentifier(name);
    }

    public static string NormalizeClassName(string databaseName) => NormalizeMethodName(databaseName);

    public static string NormalizePropertyName(string databaseName) => SanitizeIdentifier(ToPascalCase(databaseName));

    public static string NormalizeParameterName(string databaseName)
    {
        var pascalCase = ToPascalCase(databaseName);
        if (string.IsNullOrEmpty(pascalCase)) return "arg";
        var camelCase = char.ToLower(pascalCase[0]) + pascalCase.Substring(1);
        return SanitizeIdentifier(camelCase);
    }

    private static string ToPascalCase(string word)
    {
        if (string.IsNullOrEmpty(word)) return word;
        return char.ToUpper(word[0]) + word.Substring(1);
    }

    private static string SanitizeIdentifier(string identifier)
    {
        if (CSharpKeywords.Contains(identifier))
        {
            return $"@{identifier}";
        }
        return identifier;
    }

    private static string GetCSharpTypeName(VisorDbType visorDbType, bool isNullable)
    {
        var type = visorDbType switch
        {
            VisorDbType.Int32 => "int",
            VisorDbType.Int64 => "long",
            VisorDbType.Int16 => "short",
            VisorDbType.Byte => "byte",
            VisorDbType.String => "string",
            VisorDbType.Boolean => "bool",
            VisorDbType.DateTime => "DateTime",
            VisorDbType.Date => "DateTime",
            VisorDbType.Time => "TimeSpan",
            VisorDbType.DateTimeOffset => "DateTimeOffset",
            VisorDbType.Guid => "Guid",
            VisorDbType.Decimal => "decimal",
            VisorDbType.Double => "double",
            VisorDbType.Single => "float",
            VisorDbType.Binary => "byte[]",
            _ => "object"
        };

        if (isNullable && type != "string" && type != "byte[]" && type != "object")
        {
            return type + "?";
        }

        if (isNullable && type == "string") return "string?";

        return type;
    }
}
