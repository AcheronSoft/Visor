using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Visor.Generators.Strategies;

namespace Visor.Generators;

[Generator]
public class RepositoryGenerator : IIncrementalGenerator
{
    private const string VisorAttribute = nameof(VisorAttribute);
    private const string VisorShortAttribute = nameof(Visor);
    private const string EndpointAttribute = nameof(EndpointAttribute);
    private const string EndpointShortAttribute = "Endpoint";
    private const string VisorResultSetAttribute = nameof(VisorResultSetAttribute);
    private const string VisorOutputAttribute = nameof(VisorOutputAttribute);
    private const string VisorReturnValueAttribute = nameof(VisorReturnValueAttribute);
    private const string VisorColumnAttribute = nameof(VisorColumnAttribute);

    /// <summary>
    /// Holds metadata about the method's return type structure to determine if it requires complex mapping.
    /// </summary>
    private class MethodResultInfo
    {
        public bool IsComplexWrapper { get; set; }
        public IPropertySymbol? ResultSetProperty { get; set; }
        public IPropertySymbol? ReturnValueProperty { get; set; }
        public List<(IPropertySymbol Property, string ParameterName)> OutputProperties { get; } = new();
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsCandidate(node),
                transform: (generatorSyntaxContext, _) => GetVisorInterface(generatorSyntaxContext)
            )
            .Where(symbol => symbol is not null);

        context.RegisterSourceOutput(interfaceDeclarations, (sourceProductionContext, interfaceSymbol) =>
        {
            if (interfaceSymbol is null)
            {
                return;
            }

            try
            {
                var source = GenerateSource(interfaceSymbol);
                sourceProductionContext.AddSource($"{interfaceSymbol.Name}_Visor.g.cs", SourceText.From(source, Encoding.UTF8));
            }
            catch (Exception ex)
            {
                // In case of a generator crash, emit a comment file to help debugging
                var errorSource = $$"""
                                  // Error: {{ex.Message}}
                                  // {{ex.StackTrace}}
                                  """;
                sourceProductionContext.AddSource($"{interfaceSymbol.Name}_Error.g.cs", SourceText.From(errorSource, Encoding.UTF8));
            }
        });
    }

    private string GenerateSource(INamedTypeSymbol interfaceSymbol)
    {
        var stringBuilder = new StringBuilder();
        var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();
        var className = GetImplementationName(interfaceSymbol);
        
        // Collector for user-defined table types (if needed by strategy)
        var tableValuedParameterTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        var visorAttribute = interfaceSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name is VisorAttribute or VisorShortAttribute);

        var providerValue = (int)(visorAttribute?.ConstructorArguments.FirstOrDefault().Value ?? 0);

        // Select strategy based on the provider enum/integer
        IGeneratorStrategy strategy = providerValue switch
        {
            0 => new MsSqlStrategy(),
            1 => new PostgreSqlStrategy(),
            _ => new MsSqlStrategy()
        };

        GenerateClassHeader(stringBuilder, namespaceName, className, interfaceSymbol.Name, strategy);

        foreach (var member in interfaceSymbol.GetMembers())
        {
            if (member is not IMethodSymbol methodSymbol)
            {
                continue;
            }

            var endpointAttribute = methodSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name is EndpointAttribute or EndpointShortAttribute);

            if (endpointAttribute is null)
            {
                continue;
            }

            GenerateMethod(stringBuilder, methodSymbol, endpointAttribute, tableValuedParameterTypes, strategy);
        }

        strategy.GenerateHelpers(stringBuilder, tableValuedParameterTypes);

        GenerateClassFooter(stringBuilder);

        return stringBuilder.ToString();
    }

    private void GenerateClassHeader(
        StringBuilder stringBuilder, 
        string namespaceName, 
        string className, 
        string interfaceName, 
        IGeneratorStrategy strategy)
    {
        // Use a temporary builder for usings to allow the strategy to append its own
        var usingsBuilder = new StringBuilder();
        strategy.GenerateUsings(usingsBuilder);

        stringBuilder.AppendLine($$"""
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Threading;
            using System.Threading.Tasks;
            using System.Data;
            using System.Data.Common;
            using System.Collections.Generic;
            using Visor.Core;
            using Visor.Core.Exceptions;
            {{usingsBuilder}}

            namespace {{namespaceName}}
            {
                public class {{className}} : {{interfaceName}}
                {
                    private readonly IVisorConnectionFactory _factory;
            
                    public {{className}}(IVisorConnectionFactory factory)
                    {
                        _factory = factory ?? throw new ArgumentNullException(nameof(factory));
                    }
            """);
    }

    private void GenerateClassFooter(StringBuilder stringBuilder)
    {
        stringBuilder.AppendLine("""
                }
            }
            """);
    }

    private void GenerateMethod(
        StringBuilder stringBuilder, 
        IMethodSymbol method, 
        AttributeData endpointAttribute, 
        HashSet<INamedTypeSymbol> tableValuedParameterCollector, 
        IGeneratorStrategy strategy)
    {
        var procedureNameObject = endpointAttribute.ConstructorArguments[0].Value;

        if (procedureNameObject is null || string.IsNullOrWhiteSpace(procedureNameObject.ToString()))
        {
            // Note: In a real generator, use context.ReportDiagnostic here instead of throwing
            throw new ArgumentException($"Endpoint attribute on '{method.Name}' must have a valid procedure name.");
        }

        var procedureName = procedureNameObject.ToString();
        var returnType = method.ReturnType.ToDisplayString();
        var methodName = method.Name;

        // Build parameter list string
        var parameters = method.Parameters
            .Select(p => $"{p.Type.ToDisplayString()} {p.Name}")
            .ToList();
            
        var cancellationTokenName = method.Parameters
            .FirstOrDefault(p => p.Type.Name == "CancellationToken")?.Name ?? "System.Threading.CancellationToken.None";
            
        var parametersSignature = string.Join(", ", parameters);

        // Analyze return type
        var namedReturnType = method.ReturnType as INamedTypeSymbol;
        bool isVoid = namedReturnType is not null && 
                      namedReturnType.Name == "Task" && 
                      !namedReturnType.IsGenericType;

        // Check for Response Wrapper pattern (Output params / Return Value)
        MethodResultInfo methodResultInfo = new();
        if (!isVoid && namedReturnType?.TypeArguments.Length > 0)
        {
            methodResultInfo = AnalyzeReturnType(namedReturnType.TypeArguments[0]);
        }

        stringBuilder.AppendLine($$"""

                    public async {{returnType}} {{methodName}}({{parametersSignature}})
                    {
            """);
            
        strategy.GenerateOpenConnection(stringBuilder, cancellationTokenName);
        strategy.GenerateCommandInit(stringBuilder, procedureName, isVoid, method);

        foreach (var parameter in method.Parameters)
        {
            if (parameter.Type.Name == "CancellationToken")
            {
                continue;
            }
            strategy.GenerateParameter(stringBuilder, parameter, "command", tableValuedParameterCollector);
        }

        stringBuilder.AppendLine($$"""
                        try
                        {
            """);

        // Determine which execution path to take
        if (methodResultInfo.IsComplexWrapper)
        {
            GenerateComplexExecutionLogic(stringBuilder, method, methodResultInfo, strategy, cancellationTokenName);
        }
        else
        {
            GenerateExecutionLogic(stringBuilder, method, cancellationTokenName);
        }

        stringBuilder.AppendLine($$"""
                        }
                        catch (System.Data.Common.DbException ex)
                        {
                            throw new VisorExecutionException(
                                $"Error executing procedure '{command.CommandText}': {ex.Message}", 
                                "{{procedureName}}", 
                                ex.ErrorCode, 
                                ex);
                        }
                    }
            """);
    }

    /// <summary>
    /// Generates logic for standard execution scenarios: List&lt;T&gt;, Scalar, or void (Task).
    /// </summary>
    private void GenerateExecutionLogic(StringBuilder stringBuilder, IMethodSymbol method, string cancellationTokenName)
    {
        var namedReturnType = method.ReturnType as INamedTypeSymbol;
        
        // Handle: Task
        var isVoid = namedReturnType is { Name: "Task", IsGenericType: false };
        if (isVoid)
        {
            stringBuilder.AppendLine($"                await command.ExecuteNonQueryAsync({cancellationTokenName});");
            return;
        }

        var taskResultType = namedReturnType?.TypeArguments[0] as INamedTypeSymbol;
        if (taskResultType is null)
        {
            stringBuilder.AppendLine("                throw new NotImplementedException(\"Visor: Unknown return type\");");
            return;
        }

        var isCollection = taskResultType is { IsGenericType: true, Name: "List" or "IEnumerable" or "IReadOnlyList" or "IList" };

        var rowType = isCollection 
            ? taskResultType.TypeArguments[0] as INamedTypeSymbol 
            : taskResultType;

        if (rowType is null)
        {
            return;
        }

        var rowTypeName = rowType.ToDisplayString();

        stringBuilder.AppendLine($"                using var reader = await command.ExecuteReaderAsync(System.Data.CommandBehavior.Default, {cancellationTokenName});");

        if (isCollection)
        {
            stringBuilder.AppendLine($$"""
                            var list = new System.Collections.Generic.List<{{rowTypeName}}>();
                            while (await reader.ReadAsync({{cancellationTokenName}}))
                            {
            """);
        }
        else
        {
            stringBuilder.AppendLine($$"""
                            if (await reader.ReadAsync({{cancellationTokenName}}))
                            {
            """);
        }

        GenerateRowMapping(stringBuilder, rowType, "item", cancellationTokenName);

        if (isCollection)
        {
            stringBuilder.AppendLine("""
                                list.Add(item);
                            }
                            return list;
            """);
        }
        else
        {
            stringBuilder.AppendLine("""
                                return item;
                            }
                            return default!;
            """);
        }
    }

    /// <summary>
    /// Generates logic for complex scenarios involving Output parameters, ReturnValue, or wrapped ResultSets.
    /// </summary>
    private void GenerateComplexExecutionLogic(
        StringBuilder stringBuilder, 
        IMethodSymbol method, 
        MethodResultInfo methodResultInfo, 
        IGeneratorStrategy strategy, 
        string cancellationTokenName)
    {
        var wrapperType = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0];
        var wrapperTypeName = wrapperType.ToDisplayString();
        
        // Retrieve procedure name for exception context
        var procedureName = method.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name is EndpointAttribute or EndpointShortAttribute)?
            .ConstructorArguments[0].Value?.ToString() ?? "Unknown";

        stringBuilder.AppendLine($"                var result = new {wrapperTypeName}();");

        // 1. Generate OUTPUT variables and bind them
        int outputIndex = 0;
        var outputVariables = new List<(string VariableName, IPropertySymbol Property, string ParamName)>();

        foreach (var outputProp in methodResultInfo.OutputProperties)
        {
            var variableName = $"parameterOutput_{outputIndex++}";
            strategy.GenerateOutputParameter(stringBuilder, "command", outputProp.ParameterName, outputProp.Property.Type, variableName);
            outputVariables.Add((variableName, outputProp.Property, outputProp.ParameterName));
        }

        // 2. Generate RETURN_VALUE variable if required
        string returnValueVariableName = "parameterReturnValue";
        if (methodResultInfo.ReturnValueProperty is not null)
        {
            strategy.GenerateReturnValueParameter(stringBuilder, "command", returnValueVariableName);
        }

        // 3. Execution Phase
        if (methodResultInfo.ResultSetProperty is not null)
        {
            stringBuilder.AppendLine($$"""
                            using (var reader = await command.ExecuteReaderAsync(System.Data.CommandBehavior.Default, {{cancellationTokenName}}))
                            {
            """);

            var resultPropertyType = methodResultInfo.ResultSetProperty.Type as INamedTypeSymbol;
            bool isList = resultPropertyType is not null && (resultPropertyType.Name is "List" or "IEnumerable" or "IList");
            
            if (isList)
            {
                var itemType = resultPropertyType!.TypeArguments[0];
                stringBuilder.AppendLine($$"""
                                var list = new System.Collections.Generic.List<{{itemType.ToDisplayString()}}>();
                                while (await reader.ReadAsync({{cancellationTokenName}}))
                                {
                """);
                
                GenerateRowMapping(stringBuilder, itemType, "item", cancellationTokenName);
                
                stringBuilder.AppendLine($$"""
                                    list.Add(item);
                                }
                                result.{{methodResultInfo.ResultSetProperty.Name}} = list;
                """);
            }
            else
            {
                 var itemType = resultPropertyType!;
                 stringBuilder.AppendLine($$"""
                                if (await reader.ReadAsync({{cancellationTokenName}}))
                                {
                 """);
                 
                 GenerateRowMapping(stringBuilder, itemType, "item", cancellationTokenName);
                 
                 stringBuilder.AppendLine($$"""
                                    result.{{methodResultInfo.ResultSetProperty.Name}} = item;
                                }
                 """);
            }
            
            stringBuilder.AppendLine("                }"); 
        }
        else
        {
            stringBuilder.AppendLine($"                await command.ExecuteNonQueryAsync({cancellationTokenName});");
        }

        // 4. Read OUTPUT values (Wrapped in Try-Catch)
        if (outputVariables.Count > 0 || methodResultInfo.ReturnValueProperty is not null)
        {
            stringBuilder.AppendLine("""
                            try
                            {
            """);

            foreach (var (variableName, property, _) in outputVariables)
            {
                var propertyType = property.Type.ToDisplayString();
                stringBuilder.AppendLine($"                    result.{property.Name} = Visor.Core.VisorConvert.Unbox<{propertyType}>({variableName}.Value);");
            }

            if (methodResultInfo.ReturnValueProperty is not null)
            {
                var propertyType = methodResultInfo.ReturnValueProperty.Type.ToDisplayString();
                stringBuilder.AppendLine($"                    result.{methodResultInfo.ReturnValueProperty.Name} = Visor.Core.VisorConvert.Unbox<{propertyType}>({returnValueVariableName}.Value);");
            }
            
            stringBuilder.AppendLine($$"""
                            }
                            catch (System.Exception ex)
                            {
                                throw new VisorMappingException($"Error mapping output parameters in '{command.CommandText}'. See inner exception for details.", "{{procedureName}}", ex);
                            }
            """);
        }

        stringBuilder.AppendLine("                return result;");
    }

    /// <summary>
    /// Generates the mapping logic to transform a DataReader row into a C# variable.
    /// </summary>
    private void GenerateRowMapping(
        StringBuilder stringBuilder, 
        ITypeSymbol rowType, 
        string variableName, 
        string cancellationTokenName)
    {
        var rowTypeName = rowType.ToDisplayString();

        if (IsScalarType(rowType))
        {
            // Scalar mapping (int, string, guid, etc.)
            stringBuilder.AppendLine($$"""
                                {{rowTypeName}} {{variableName}};
                                if (!reader.IsDBNull(0))
                                    {{variableName}} = await reader.GetFieldValueAsync<{{rowTypeName}}>(0, {{cancellationTokenName}});
                                else
                                    {{variableName}} = default;
            """);
        }
        else 
        {
            // Complex Object mapping
            stringBuilder.AppendLine($"                    var {variableName} = new {rowTypeName}();");
                 
            foreach (var property in rowType.GetMembers().OfType<IPropertySymbol>())
            {
                if (property.IsStatic || property.DeclaredAccessibility != Accessibility.Public || property.SetMethod is null)
                {
                    continue;
                }

                var databaseColumnName = property.Name;
                    
                // Check for [VisorColumn] attribute
                var columnAttribute = property.GetAttributes()
                    .FirstOrDefault(a => a.AttributeClass?.Name is VisorColumnAttribute or "VisorColumn");
                    
                if (columnAttribute is not null)
                {
                    var nameArgument = columnAttribute.NamedArguments.FirstOrDefault(na => na.Key == "Name");
                    if (nameArgument is { Key: not null, Value.Value: not null })
                    {
                        databaseColumnName = nameArgument.Value.Value.ToString();
                    }
                }

                // Generates individual try-catch blocks per column for robust mapping
                stringBuilder.AppendLine($$"""
                                try 
                                {
                                    int ordinal = reader.GetOrdinal("{{databaseColumnName}}");
                                    if (!reader.IsDBNull(ordinal)) 
                                    {
                                        {{variableName}}.{{property.Name}} = await reader.GetFieldValueAsync<{{property.Type.ToDisplayString()}}>(ordinal, {{cancellationTokenName}});
                                    }
                                } 
                                catch (IndexOutOfRangeException ex) 
                                { 
                                    throw new VisorMappingException(
                                        $"Mapping error: Column '{{databaseColumnName}}' not found in result set. Check your DTO.", 
                                        command.CommandText, 
                                        ex);
                                }
                """);
            }
        }
    }

    private MethodResultInfo AnalyzeReturnType(ITypeSymbol typeSymbol)
    {
        var methodResultInfo = new MethodResultInfo();
            
        if (typeSymbol.SpecialType != SpecialType.None || typeSymbol.Name == "List" || typeSymbol is IArrayTypeSymbol)
        {
            return methodResultInfo;
        }

        foreach (var property in typeSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var attributes = property.GetAttributes();

            if (attributes.Any(a => a.AttributeClass?.Name == VisorResultSetAttribute)) 
            { 
                methodResultInfo.ResultSetProperty = property; 
                methodResultInfo.IsComplexWrapper = true; 
            }

            if (attributes.Any(a => a.AttributeClass?.Name == VisorReturnValueAttribute)) 
            { 
                methodResultInfo.ReturnValueProperty = property; 
                methodResultInfo.IsComplexWrapper = true; 
            }
                
            var outputAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == VisorOutputAttribute);
            if (outputAttribute is not null)
            {
                var parameterName = outputAttribute.ConstructorArguments.FirstOrDefault().Value?.ToString();
                if (!string.IsNullOrEmpty(parameterName)) 
                { 
                    methodResultInfo.OutputProperties.Add((property, parameterName!)); 
                    methodResultInfo.IsComplexWrapper = true; 
                }
            }
        }
        return methodResultInfo;
    }
    
    private string GetImplementationName(INamedTypeSymbol interfaceSymbol)
    {
        if (interfaceSymbol.Name.StartsWith("I") && 
            interfaceSymbol.Name.Length > 1 && 
            char.IsUpper(interfaceSymbol.Name[1]))
        {
            return interfaceSymbol.Name.Substring(1);
        }
            
        return $"{interfaceSymbol.Name}Generated";
    }

    private bool IsScalarType(ITypeSymbol type)
    {
        return type.SpecialType != SpecialType.None
               || type.Name is "Guid" or "DateTime" or "DateTimeOffset" or "TimeSpan" or "Decimal";
    }

    private static bool IsCandidate(SyntaxNode node) 
        => node is InterfaceDeclarationSyntax { AttributeLists.Count: > 0 };

    private static INamedTypeSymbol? GetVisorInterface(GeneratorSyntaxContext context)
    {
        var interfaceDeclaration = (InterfaceDeclarationSyntax)context.Node;
            
        if (context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol symbol)
        {
            return null;
        }
            
        return symbol.GetAttributes()
            .Any(a => a.AttributeClass?.Name is VisorAttribute or VisorShortAttribute) 
            ? symbol 
            : null;
    }
}