using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Visor.Generators.Strategies;

namespace Visor.Generators
{
    [Generator]
    public class RepositoryGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var interfaceDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsCandidate(node),
                    transform: (generatorSyntaxContext, _) => GetVisorInterface(generatorSyntaxContext)
                )
                .Where(symbol => symbol != null);

            context.RegisterSourceOutput(interfaceDeclarations, (sourceProductionContext, interfaceSymbol) =>
            {
                if (interfaceSymbol == null) 
                    return;
                
                try 
                {
                    var source = GenerateSource(interfaceSymbol);
                    sourceProductionContext.AddSource($"{interfaceSymbol.Name}_Visor.g.cs", SourceText.From(source, Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    var errorSource = $"// Error: {ex.Message}\n// {ex.StackTrace}";
                    sourceProductionContext.AddSource($"{interfaceSymbol.Name}_Error.g.cs", SourceText.From(errorSource, Encoding.UTF8));
                }
            });
        }

        private string GenerateSource(INamedTypeSymbol interfaceSymbol)
        {
            var stringBuilder = new StringBuilder();
            var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();
            var className = GetImplementationName(interfaceSymbol);
            var tableValuedParameterTypes = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            var visorAttribute = interfaceSymbol.GetAttributes()
                .FirstOrDefault(attributeData => attributeData.AttributeClass?.Name is "VisorAttribute" or "Visor");

            var providerValue = (int)(visorAttribute?.ConstructorArguments.FirstOrDefault().Value ?? 0);

            IGeneratorStrategy strategy = providerValue switch
            {
                0 => new MsSqlStrategy(),
                1 => new PostgreSqlStrategy(),
                _ => new MsSqlStrategy()
            };

            GenerateClassHeader(stringBuilder, namespaceName, className, interfaceSymbol.Name, strategy);

            foreach (var member in interfaceSymbol.GetMembers())
            {
                if (member is not IMethodSymbol methodSymbol) continue;

                var endpointAttribute = methodSymbol.GetAttributes()
                    .FirstOrDefault(attributeData => attributeData.AttributeClass?.Name is "EndpointAttribute" or "Endpoint");

                if (endpointAttribute == null) continue;

                GenerateMethod(stringBuilder, methodSymbol, endpointAttribute, tableValuedParameterTypes, strategy);
            }

            strategy.GenerateHelpers(stringBuilder, tableValuedParameterTypes);

            GenerateClassFooter(stringBuilder);
            return stringBuilder.ToString();
        }

        private void GenerateClassHeader(StringBuilder stringBuilder, string namespaceName, string className, string interfaceName, IGeneratorStrategy strategy)
        {
            stringBuilder.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using Visor.Core;
using Visor.Core.Exceptions;");
            
            strategy.GenerateUsings(stringBuilder);

            stringBuilder.AppendLine($@"
namespace {namespaceName}
{{
    public class {className} : {interfaceName}
    {{
        private readonly IVisorConnectionFactory _factory;

        public {className}(IVisorConnectionFactory factory)
        {{
            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
        }}");
        }

        private void GenerateClassFooter(StringBuilder stringBuilder)
        {
            stringBuilder.AppendLine(@"
    }
}");
        }

        private void GenerateMethod(StringBuilder stringBuilder, IMethodSymbol method, AttributeData endpointAttribute, HashSet<INamedTypeSymbol> tableValuedParameterCollector, IGeneratorStrategy strategy)
        {
            var procedureNameObject = endpointAttribute.ConstructorArguments[0].Value;

            if (procedureNameObject == null || string.IsNullOrWhiteSpace(procedureNameObject.ToString()))
            {
                throw new ArgumentException($"Endpoint attribute on '{method.Name}' must have a valid procedure name.");
            }

            var procedureName = procedureNameObject.ToString();
            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;

            var parameters = method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}").ToList();
            var cancellationTokenName = method.Parameters.FirstOrDefault(p => p.Type.Name == "CancellationToken")?.Name 
                                        ?? "System.Threading.CancellationToken.None";
            
            var parametersSignature = string.Join(", ", parameters);

            var namedReturnType = method.ReturnType as INamedTypeSymbol;
            bool isVoid = namedReturnType != null && 
                          namedReturnType.Name == "Task" && 
                          !namedReturnType.IsGenericType;

            stringBuilder.AppendLine($@"
        public async {returnType} {methodName}({parametersSignature})
        {{");
            
            strategy.GenerateOpenConnection(stringBuilder, cancellationTokenName);
            
            strategy.GenerateCommandInit(stringBuilder, procedureName, isVoid, method);

            foreach (var parameter in method.Parameters)
            {
                if (parameter.Type.Name == "CancellationToken") continue;
                strategy.GenerateParameter(stringBuilder, parameter, "command", tableValuedParameterCollector);
            }

            stringBuilder.AppendLine(@"
            try
            {");

            GenerateExecutionLogic(stringBuilder, method, cancellationTokenName);

            stringBuilder.AppendLine($@"            }}
            catch (System.Data.Common.DbException ex)
            {{
                throw new VisorExecutionException(
                    $""Error executing procedure '{{command.CommandText}}': {{ex.Message}}"", 
                    ""{procedureName}"", 
                    ex.ErrorCode, 
                    ex);
            }}
        }}");
        }

        private void GenerateExecutionLogic(StringBuilder stringBuilder, IMethodSymbol method, string cancellationTokenName)
        {
            var namedReturnType = method.ReturnType as INamedTypeSymbol;
            var isVoid = namedReturnType is { Name: "Task", IsGenericType: false };

            if (isVoid)
            {
                stringBuilder.AppendLine($@"                await command.ExecuteNonQueryAsync({cancellationTokenName});");
                return;
            }

            var taskResultType = namedReturnType?.TypeArguments[0] as INamedTypeSymbol;
            if (taskResultType == null)
            {
                stringBuilder.AppendLine(@"                throw new NotImplementedException(""Visor: Unknown return type"");");
                return;
            }

            var isCollection = taskResultType is { IsGenericType: true, Name: "List" or "IEnumerable" or "IReadOnlyList" or "IList" };

            var rowType = isCollection 
                ? taskResultType.TypeArguments[0] as INamedTypeSymbol 
                : taskResultType;

            if (rowType == null) return;

            var rowTypeName = rowType.ToDisplayString();
            bool isScalar = IsScalarType(rowType);

            stringBuilder.AppendLine($@"                using var reader = await command.ExecuteReaderAsync(System.Data.CommandBehavior.Default, {cancellationTokenName});");

            if (isCollection)
            {
                stringBuilder.AppendLine($@"
                var list = new System.Collections.Generic.List<{rowTypeName}>();
                while (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }
            else
            {
                stringBuilder.AppendLine($@"
                if (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }

            if (isScalar)
            {
                stringBuilder.AppendLine($@"
                    {rowTypeName} item;
                    if (!reader.IsDBNull(0))
                        item = await reader.GetFieldValueAsync<{rowTypeName}>(0, {cancellationTokenName});
                    else
                        item = default;");
            }
            else
            {
                stringBuilder.AppendLine($@"
                    var item = new {rowTypeName}();");

                foreach (var property in rowType.GetMembers().OfType<IPropertySymbol>())
                {
                    if (property.IsStatic || property.DeclaredAccessibility != Accessibility.Public || property.SetMethod == null) 
                        continue;

                    var propertyType = property.Type.ToDisplayString();
                    var propertyName = property.Name;
                    
                    var databaseColumnName = propertyName;
                    
                    var columnAttribute = property.GetAttributes().FirstOrDefault(a => 
                        a.AttributeClass?.Name is 
                            "VisorColumnAttribute" or 
                            "VisorColumn" or 
                            "VisorMsSqlColumnAttribute" or 
                            "VisorMsSqlColumn" or 
                            "VisorPgColumnAttribute" or 
                            "VisorPgColumn");
                    
                    if (columnAttribute != null)
                    {
                        var nameArgument = columnAttribute.NamedArguments.FirstOrDefault(na => na.Key == "Name");
                        if (nameArgument is { Key: not null, Value.Value: not null })
                        {
                            databaseColumnName = nameArgument.Value.Value.ToString();
                        }
                    }

                    stringBuilder.AppendLine($@"
                    try 
                    {{
                        int ordinal_{propertyName} = reader.GetOrdinal(""{databaseColumnName}"");
                        if (!reader.IsDBNull(ordinal_{propertyName}))
                        {{
                            item.{propertyName} = await reader.GetFieldValueAsync<{propertyType}>(ordinal_{propertyName}, {cancellationTokenName});
                        }}
                    }}
                    catch (IndexOutOfRangeException ex) 
                    {{ 
                        throw new VisorMappingException(
                            $""Mapping error: Column '{{""{databaseColumnName}""}}' not found in result set. Check your DTO."", 
                            command.CommandText, 
                            ex);
                    }}");
                }
            }

            if (isCollection)
            {
                stringBuilder.AppendLine(@"
                    list.Add(item);
                }
                return list;");
            }
            else
            {
                stringBuilder.AppendLine(@"
                    return item;
                }
                return default!;");
            }
        }

        private string GetImplementationName(INamedTypeSymbol interfaceSymbol)
        {
            if (interfaceSymbol.Name.StartsWith("I") && 
                interfaceSymbol.Name.Length > 1 && 
                char.IsUpper(interfaceSymbol.Name[1]))
            {
                return interfaceSymbol.Name.Substring(1);
            }
            
            return interfaceSymbol.Name + "Generated";
        }

        private bool IsScalarType(ITypeSymbol type)
        {
            return type.SpecialType != SpecialType.None
                   || type.Name == "Guid"
                   || type.Name == "DateTime"
                   || type.Name == "DateTimeOffset"
                   || type.Name == "TimeSpan"
                   || type.Name == "Decimal";
        }

        private static bool IsCandidate(SyntaxNode node) => node is InterfaceDeclarationSyntax interfaceDeclarationSyntax && interfaceDeclarationSyntax.AttributeLists.Count > 0;

        private static INamedTypeSymbol? GetVisorInterface(GeneratorSyntaxContext context)
        {
            var interfaceDeclaration = (InterfaceDeclarationSyntax)context.Node;
            
            if (context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) is not INamedTypeSymbol symbol) 
                return null;
            
            return symbol.GetAttributes().Any(attributeData => attributeData.AttributeClass?.Name is "VisorAttribute" or "Visor") 
                ? symbol 
                : null;
        }
    }
}
