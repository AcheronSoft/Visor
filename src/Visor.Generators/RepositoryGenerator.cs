using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Visor.Generators.Strategies;

namespace Visor.Generators
{
    [Generator]
    public class RepositoryGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsCandidate(node),
                    transform: (ctx, _) => GetVisorInterface(ctx)
                )
                .Where(m => m != null);

            context.RegisterSourceOutput(provider, (spc, interfaceSymbol) =>
            {
                if (interfaceSymbol == null) return;
                
                try 
                {
                    var source = GenerateSource(interfaceSymbol);
                    spc.AddSource($"{interfaceSymbol.Name}_Visor.g.cs", SourceText.From(source, Encoding.UTF8));
                }
                catch (Exception ex)
                {
                    // Если что-то пошло не так, генерируем файл с ошибкой в комментарии, чтобы видеть в IDE
                    var errorSource = $"// Error generating source: {ex.Message}\n// {ex.StackTrace}";
                    spc.AddSource($"{interfaceSymbol.Name}_Error.g.cs", SourceText.From(errorSource, Encoding.UTF8));
                }
            });
        }

        private string GenerateSource(INamedTypeSymbol interfaceSymbol)
        {
            var sb = new StringBuilder();
            var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();
            var className = GetImplementationName(interfaceSymbol);
            var tvpTypesToGenerate = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            // 1. Определяем стратегию (Провайдер)
            var visorAttr = interfaceSymbol.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == "VisorAttribute" || ad.AttributeClass?.Name == "Visor");

            // Получаем значение Enum (int) из конструктора атрибута [Visor(Provider)]
            // По умолчанию 0 (SqlServer)
            var providerValue = (int)(visorAttr?.ConstructorArguments.FirstOrDefault().Value ?? 0);

            IGeneratorStrategy strategy = providerValue switch
            {
                // 0 = SqlServer
                0 => new MsSqlStrategy(),
                
                // 1 = PostgreSql
                1 => new PostgreSqlStrategy(),
                
                _ => new MsSqlStrategy()
            };

            // 2. Генерация шапки (Using'и зависят от стратегии)
            GenerateClassHeader(sb, namespaceName, className, interfaceSymbol.Name, strategy);

            // 3. Генерация методов
            foreach (var member in interfaceSymbol.GetMembers())
            {
                if (member is not IMethodSymbol methodSymbol) continue;

                var endpointAttr = methodSymbol.GetAttributes()
                    .FirstOrDefault(ad => ad.AttributeClass?.Name == "EndpointAttribute" || ad.AttributeClass?.Name == "Endpoint");

                if (endpointAttr == null) continue;

                GenerateMethod(sb, methodSymbol, endpointAttr, tvpTypesToGenerate, strategy);
            }

            // 4. Генерация хелперов (TVP / Arrays) - делегируем стратегии
            strategy.GenerateHelpers(sb, tvpTypesToGenerate);

            GenerateClassFooter(sb);
            return sb.ToString();
        }

        private void GenerateClassHeader(StringBuilder sb, string namespaceName, string className, string interfaceName, IGeneratorStrategy strategy)
        {
            sb.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using Visor.Core;");
            
            // Стратегия добавляет свои юзинги (Microsoft.Data.SqlClient или Npgsql)
            strategy.GenerateUsings(sb);

            sb.AppendLine($@"
namespace {namespaceName}
{{
    public class {className} : {interfaceName}
    {{
        private readonly IVisorConnectionFactory _factory;

        public {className}(IVisorConnectionFactory factory)
        {{
            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
        }}");
        }

        private void GenerateClassFooter(StringBuilder sb)
        {
            sb.AppendLine(@"
    }
}");
        }

        private void GenerateMethod(StringBuilder sb, IMethodSymbol method, AttributeData endpointAttr, HashSet<INamedTypeSymbol> tvpCollector, IGeneratorStrategy strategy)
        {
            var procName = endpointAttr.ConstructorArguments[0].Value?.ToString();
            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;

            var parameters = method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}").ToList();
            var cancellationParamName = method.Parameters.FirstOrDefault(p => p.Type.Name == "CancellationToken")?.Name 
                                        ?? "System.Threading.CancellationToken.None";
            
            var parametersSignature = string.Join(", ", parameters);

            sb.AppendLine($@"
        public async {returnType} {methodName}({parametersSignature})
        {{");
            
            // Стратегия пишет код открытия соединения
            strategy.GenerateOpenConnection(sb, cancellationParamName);
            
            sb.AppendLine($@"
            command.CommandText = ""{procName}"";
            command.CommandType = CommandType.StoredProcedure;");

            // Стратегия пишет код параметров (SqlParameter vs NpgsqlParameter)
            foreach (var param in method.Parameters)
            {
                if (param.Type.Name == "CancellationToken") continue;
                
                // Передаем "command" как имя переменной команды
                strategy.GenerateParameter(sb, param, "command", tvpCollector);
            }

            sb.AppendLine(@"
            try
            {");

            // Логика выполнения (ExecuteReader) - она общая, т.к. мы используем DbDataReader
            GenerateExecutionLogic(sb, method, cancellationParamName);

            sb.AppendLine($@"            }}
            catch (System.Data.Common.DbException ex)
            {{
                throw new VisorExecutionException(
                    $""Error executing procedure '{{command.CommandText}}': {{ex.Message}}"", 
                    ""{procName}"", 
                    ex.ErrorCode, 
                    ex);
            }}
        }}");
        }

        private void GenerateExecutionLogic(StringBuilder sb, IMethodSymbol method, string cancellationTokenName)
        {
            var namedReturnType = method.ReturnType as INamedTypeSymbol;
            bool isVoid = namedReturnType != null && 
                          namedReturnType.Name == "Task" && 
                          !namedReturnType.IsGenericType;

            if (isVoid)
            {
                sb.AppendLine($@"                await command.ExecuteNonQueryAsync({cancellationTokenName});");
                return;
            }

            var taskResultType = namedReturnType?.TypeArguments[0] as INamedTypeSymbol;
            if (taskResultType == null)
            {
                sb.AppendLine(@"                throw new NotImplementedException(""Visor: Unknown return type"");");
                return;
            }

            bool isCollection = taskResultType.IsGenericType && 
                               (taskResultType.Name == "List" || 
                                taskResultType.Name == "IEnumerable" || 
                                taskResultType.Name == "IReadOnlyList" ||
                                taskResultType.Name == "IList");

            var rowType = isCollection 
                ? taskResultType.TypeArguments[0] as INamedTypeSymbol 
                : taskResultType;

            if (rowType == null) return;

            var rowTypeName = rowType.ToDisplayString();
            bool isScalar = IsScalarType(rowType);

            sb.AppendLine($@"                using var reader = await command.ExecuteReaderAsync(System.Data.CommandBehavior.Default, {cancellationTokenName});");

            if (isCollection)
            {
                sb.AppendLine($@"
                var list = new System.Collections.Generic.List<{rowTypeName}>();
                while (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }
            else
            {
                sb.AppendLine($@"
                if (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }

            if (isScalar)
            {
                sb.AppendLine($@"
                    {rowTypeName} item;
                    if (!reader.IsDBNull(0))
                        item = await reader.GetFieldValueAsync<{rowTypeName}>(0, {cancellationTokenName});
                    else
                        item = default;");
            }
            else
            {
                sb.AppendLine($@"
                    var item = new {rowTypeName}();");

                foreach (var prop in rowType.GetMembers().OfType<IPropertySymbol>())
                {
                    if (prop.IsStatic || prop.DeclaredAccessibility != Accessibility.Public || prop.SetMethod == null) 
                        continue;

                    var propType = prop.Type.ToDisplayString();
                    var propName = prop.Name;

                    sb.AppendLine($@"
                    try 
                    {{
                        int ord_{propName} = reader.GetOrdinal(""{propName}"");
                        if (!reader.IsDBNull(ord_{propName}))
                        {{
                            item.{propName} = await reader.GetFieldValueAsync<{propType}>(ord_{propName}, {cancellationTokenName});
                        }}
                    }}
                    catch (IndexOutOfRangeException ex) 
                    {{ 
                        throw new VisorMappingException(
                            $""Mapping error: Column '{{""{propName}""}}' not found in result set. Check your DTO."", 
                            command.CommandText, 
                            ex);
                    }}");
                }
            }

            if (isCollection)
            {
                sb.AppendLine(@"
                    list.Add(item);
                }
                return list;");
            }
            else
            {
                // Подавление warning CS8603 (возврат null)
                sb.AppendLine(@"
                    return item;
                }
                return default!;");
            }
        }

        // --- ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ (Общие) ---

        private string GetImplementationName(INamedTypeSymbol interfaceSymbol)
        {
            return interfaceSymbol.Name.StartsWith("I") && interfaceSymbol.Name.Length > 1
                ? interfaceSymbol.Name.Substring(1) + "Implementation"
                : interfaceSymbol.Name + "Implementation";
        }

        private bool IsScalarType(ITypeSymbol type)
        {
            return type.SpecialType != SpecialType.None
                   || type.Name == "Guid"
                   || type.Name == "DateTime"
                   || type.Name == "DateTimeOffset"
                   || type.Name == "TimeSpan"
                   || type.Name == "Decimal";
        }

        private static bool IsCandidate(SyntaxNode node) => node is InterfaceDeclarationSyntax i && i.AttributeLists.Count > 0;

        private static INamedTypeSymbol? GetVisorInterface(GeneratorSyntaxContext context)
        {
            var interfaceDeclaration = (InterfaceDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) as INamedTypeSymbol;
            if (symbol == null) return null;
            return symbol.GetAttributes().Any(ad => ad.AttributeClass?.Name == "VisorAttribute" || ad.AttributeClass?.Name == "Visor") ? symbol : null;
        }
    }
}