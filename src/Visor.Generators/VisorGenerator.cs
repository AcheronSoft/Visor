using System;
using System.Linq;
using System.Text;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visor.Generators
{
    [Generator]
    public class VisorGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsCandidate(node),
                    transform: (ctx, _) => GetVisorInterface(ctx)
                )
                .Where(m => m != null);

            context.RegisterSourceOutput(provider, (spc, interfaceSymbol) =>
            {
                if (interfaceSymbol == null) return;
                var source = GenerateSource(interfaceSymbol);
                spc.AddSource($"{interfaceSymbol.Name}_Visor.g.cs", SourceText.From(source, Encoding.UTF8));
            });
        }

        private string GenerateSource(INamedTypeSymbol interfaceSymbol)
        {
            var sb = new StringBuilder();
            var namespaceName = interfaceSymbol.ContainingNamespace.ToDisplayString();
            var className = GetImplementationName(interfaceSymbol);
            var tvpTypesToGenerate = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

            GenerateClassHeader(sb, namespaceName, className, interfaceSymbol.Name);

            foreach (var member in interfaceSymbol.GetMembers())
            {
                if (member is not IMethodSymbol methodSymbol) continue;

                var endpointAttr = methodSymbol.GetAttributes()
                    .FirstOrDefault(ad => ad.AttributeClass?.Name == "EndpointAttribute" || ad.AttributeClass?.Name == "Endpoint");

                if (endpointAttr == null) continue;

                GenerateMethod(sb, methodSymbol, endpointAttr, tvpTypesToGenerate);
            }

            foreach (var tvpType in tvpTypesToGenerate)
            {
                GenerateTvpHelperMethod(sb, tvpType);
            }

            GenerateClassFooter(sb);
            return sb.ToString();
        }

        private void GenerateClassHeader(StringBuilder sb, string namespaceName, string className, string interfaceName)
        {
            sb.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using Microsoft.Data.SqlClient;
using Microsoft.Data.SqlClient.Server;
using Visor.Core;

namespace {namespaceName}
{{
    public class {className} : {interfaceName}
    {{
        private readonly IVisorConnectionFactory _factory;

        public {className}(IVisorConnectionFactory factory)
        {{
            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
        }}");
        }

        private void GenerateClassFooter(StringBuilder sb)
        {
            sb.AppendLine(@"
    }
}");
        }

        private void GenerateMethod(StringBuilder sb, IMethodSymbol method, AttributeData endpointAttr, HashSet<INamedTypeSymbol> tvpCollector)
        {
            var procName = endpointAttr.ConstructorArguments[0].Value?.ToString();
            var returnType = method.ReturnType.ToDisplayString();
            var methodName = method.Name;

            var parameters = method.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}").ToList();
            var cancellationParamName = method.Parameters.FirstOrDefault(p => p.Type.Name == "CancellationToken")?.Name 
                                        ?? "System.Threading.CancellationToken.None";
            
            var parametersSignature = string.Join(", ", parameters);

            sb.AppendLine($@"
        public async {returnType} {methodName}({parametersSignature})
        {{
            // ИЗМЕНЕНИЕ: Используем Lease и OpenAsync
            await using var lease = await _factory.OpenAsync({cancellationParamName});
            using var command = lease.Connection.CreateCommand();
            
            // ИЗМЕНЕНИЕ: Привязываем транзакцию (если она есть)
            command.Transaction = lease.Transaction;
            
            command.CommandText = ""{procName}"";
            command.CommandType = CommandType.StoredProcedure;");

            GenerateParameters(sb, method.Parameters, tvpCollector);

            sb.AppendLine(@"
            try
            {");

            GenerateExecutionLogic(sb, method, cancellationParamName);

            sb.AppendLine($@"            }}
            catch (System.Data.Common.DbException ex)
            {{
                throw new VisorExecutionException(
                    $""Error executing procedure '{{command.CommandText}}': {{ex.Message}}"", 
                    ""{procName}"", 
                    ex.ErrorCode, 
                    ex);
            }}
        }}");
        }

        private void GenerateParameters(StringBuilder sb, System.Collections.Immutable.ImmutableArray<IParameterSymbol> parameters, HashSet<INamedTypeSymbol> tvpCollector)
        {
            foreach (var param in parameters)
            {
                if (param.Type.Name == "CancellationToken") continue;

                if (IsTvpParam(param.Type, out var itemType, out var sqlTypeName))
                {
                    tvpCollector.Add(itemType!);
                    var safeItemTypeName = itemType!.Name;

                    sb.AppendLine($@"
            var p_{param.Name} = (Microsoft.Data.SqlClient.SqlParameter)command.CreateParameter();
            p_{param.Name}.ParameterName = ""{param.Name}""; 
            p_{param.Name}.SqlDbType = SqlDbType.Structured;
            p_{param.Name}.TypeName = ""{sqlTypeName}""; 
            
            if ({param.Name} != null)
            {{
                p_{param.Name}.Value = MapToSqlDataRecord_{safeItemTypeName}({param.Name});
            }}
            else
            {{
                p_{param.Name}.Value = DBNull.Value;
            }}
            command.Parameters.Add(p_{param.Name});");
                }
                else
                {
                    var dbParamName = param.Name;
                    bool canBeNull = param.Type.IsReferenceType ||
                                     (param.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T);

                    var valueCode = canBeNull
                        ? $"(object){param.Name} ?? DBNull.Value"
                        : $"(object){param.Name}";

                    sb.AppendLine($@"
            var p_{param.Name} = command.CreateParameter();
            p_{param.Name}.ParameterName = ""{dbParamName}"";
            p_{param.Name}.Value = {valueCode};
            command.Parameters.Add(p_{param.Name});");
                }
            }
        }

        private void GenerateExecutionLogic(StringBuilder sb, IMethodSymbol method, string cancellationTokenName)
        {
            var namedReturnType = method.ReturnType as INamedTypeSymbol;
            bool isVoid = namedReturnType != null &&
                          namedReturnType.Name == "Task" &&
                          !namedReturnType.IsGenericType;

            if (isVoid)
            {
                sb.AppendLine($@"                await command.ExecuteNonQueryAsync({cancellationTokenName});");
                return;
            }

            var taskResultType = namedReturnType?.TypeArguments[0] as INamedTypeSymbol;
            if (taskResultType == null)
            {
                sb.AppendLine(@"                throw new NotImplementedException(""Visor: Unknown return type"");");
                return;
            }

            bool isCollection = taskResultType.IsGenericType &&
                               (taskResultType.Name == "List" ||
                                taskResultType.Name == "IEnumerable" ||
                                taskResultType.Name == "IReadOnlyList" ||
                                taskResultType.Name == "IList");

            var rowType = isCollection
                ? taskResultType.TypeArguments[0] as INamedTypeSymbol
                : taskResultType;

            if (rowType == null) return;

            var rowTypeName = rowType.ToDisplayString();
            bool isScalar = IsScalarType(rowType);

            sb.AppendLine($@"                using var reader = await command.ExecuteReaderAsync(System.Data.CommandBehavior.Default, {cancellationTokenName});");

            if (isCollection)
            {
                sb.AppendLine($@"
                var list = new System.Collections.Generic.List<{rowTypeName}>();
                while (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }
            else
            {
                sb.AppendLine($@"
                if (await reader.ReadAsync({cancellationTokenName}))
                {{");
            }

            if (isScalar)
            {
                sb.AppendLine($@"
                    {rowTypeName} item;
                    if (!reader.IsDBNull(0))
                        item = await reader.GetFieldValueAsync<{rowTypeName}>(0, {cancellationTokenName});
                    else
                        item = default;");
            }
            else
            {
                sb.AppendLine($@"
                    var item = new {rowTypeName}();");

                foreach (var prop in rowType.GetMembers().OfType<IPropertySymbol>())
                {
                    if (prop.IsStatic || prop.DeclaredAccessibility != Accessibility.Public || prop.SetMethod == null)
                        continue;

                    var propType = prop.Type.ToDisplayString();
                    var propName = prop.Name;

                    sb.AppendLine($@"
                    try 
                    {{
                        int ord_{propName} = reader.GetOrdinal(""{propName}"");
                        if (!reader.IsDBNull(ord_{propName}))
                        {{
                            item.{propName} = await reader.GetFieldValueAsync<{propType}>(ord_{propName}, {cancellationTokenName});
                        }}
                    }}
                    catch (IndexOutOfRangeException ex) 
                    {{ 
                        throw new VisorMappingException(
                            $""Mapping error: Column '{{""{propName}""}}' not found in result set. Check your DTO."", 
                            command.CommandText, 
                            ex);
                    }}");
                }
            }

            if (isCollection)
            {
                sb.AppendLine(@"
                    list.Add(item);
                }
                return list;");
            }
            else
            {
                sb.AppendLine(@"
                    return item;
                }
                return default!;");
            }
        }

        private void GenerateTvpHelperMethod(StringBuilder sb, INamedTypeSymbol itemType)
        {
            var props = itemType.GetMembers().OfType<IPropertySymbol>()
                .Select(p => new { Property = p, Attr = p.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "VisorColumnAttribute" || a.AttributeClass?.Name == "VisorColumn") })
                .Where(x => x.Attr != null)
                .OrderBy(x => (int)x.Attr!.ConstructorArguments[0].Value!)
                .ToList();

            var methodName = $"MapToSqlDataRecord_{itemType.Name}";

            sb.AppendLine($@"
        private static System.Collections.Generic.IEnumerable<SqlDataRecord> {methodName}(System.Collections.Generic.IEnumerable<{itemType.ToDisplayString()}> rows)
        {{
            var meta = new SqlMetaData[]
            {{");

            foreach (var p in props)
            {
                var name = p.Property.Name;
                var sqlDbType = (int)p.Attr!.ConstructorArguments[1].Value!;
                var size = (int)p.Attr!.ConstructorArguments[2].Value!;
                var sqlDbTypeEnum = ((System.Data.SqlDbType)sqlDbType).ToString();

                var sizeStr = (size > 0 || sqlDbTypeEnum == "NVarChar" || sqlDbTypeEnum == "VarChar" || sqlDbTypeEnum == "Char") && size > 0 
                    ? size.ToString() 
                    : "SqlMetaData.Max";

                if (size > 0 || sqlDbTypeEnum.Contains("Char"))
                     sb.AppendLine($@"                new SqlMetaData(""{name}"", SqlDbType.{sqlDbTypeEnum}, {sizeStr}),");
                else
                     sb.AppendLine($@"                new SqlMetaData(""{name}"", SqlDbType.{sqlDbTypeEnum}),");
            }

            sb.AppendLine(@"            };
            
            var record = new SqlDataRecord(meta);
            
            foreach (var row in rows)
            {");

            for (int i = 0; i < props.Count; i++)
            {
                var p = props[i];
                var propName = p.Property.Name;
                var sqlDbType = (System.Data.SqlDbType)p.Attr!.ConstructorArguments[1].Value!;
                var setMethod = GetSetMethodName(sqlDbType);

                if (p.Property.Type.IsReferenceType || p.Property.Type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
                    sb.AppendLine($@"                if (row.{propName} == null) record.SetDBNull({i}); else record.{setMethod}({i}, row.{propName});");
                else
                    sb.AppendLine($@"                record.{setMethod}({i}, row.{propName});");
            }

            sb.AppendLine(@"                yield return record;
            }
        }");
        }

        private string GetImplementationName(INamedTypeSymbol interfaceSymbol)
        {
            return interfaceSymbol.Name.StartsWith("I") && interfaceSymbol.Name.Length > 1
                ? interfaceSymbol.Name.Substring(1) + "Implementation"
                : interfaceSymbol.Name + "Implementation";
        }

        private string GetSetMethodName(System.Data.SqlDbType dbType) => dbType switch
        {
            System.Data.SqlDbType.Int => "SetInt32",
            System.Data.SqlDbType.BigInt => "SetInt64",
            System.Data.SqlDbType.SmallInt => "SetInt16",
            System.Data.SqlDbType.TinyInt => "SetByte",
            System.Data.SqlDbType.Bit => "SetBoolean",
            System.Data.SqlDbType.NVarChar or System.Data.SqlDbType.VarChar or System.Data.SqlDbType.Char or System.Data.SqlDbType.NChar or System.Data.SqlDbType.Text or System.Data.SqlDbType.Xml => "SetString",
            System.Data.SqlDbType.DateTime or System.Data.SqlDbType.SmallDateTime or System.Data.SqlDbType.Date or System.Data.SqlDbType.DateTime2 => "SetDateTime",
            System.Data.SqlDbType.Decimal or System.Data.SqlDbType.Money or System.Data.SqlDbType.SmallMoney => "SetDecimal",
            System.Data.SqlDbType.Float => "SetDouble",
            System.Data.SqlDbType.Real => "SetFloat",
            System.Data.SqlDbType.UniqueIdentifier => "SetGuid",
            System.Data.SqlDbType.Binary or System.Data.SqlDbType.VarBinary or System.Data.SqlDbType.Image => "SetBytes",
            _ => "SetValue"
        };

        private bool IsTvpParam(ITypeSymbol type, out INamedTypeSymbol? itemType, out string? sqlTypeName)
        {
            itemType = null;
            sqlTypeName = null;
            if (type is not INamedTypeSymbol namedType) return false;
            var isCollection = namedType.IsGenericType && (namedType.Name == "List" || namedType.Name == "IEnumerable" || namedType.Name == "IList" || namedType.Name == "IReadOnlyList");
            if (!isCollection) return false;
            itemType = namedType.TypeArguments[0] as INamedTypeSymbol;
            if (itemType == null) return false;
            var attr = itemType.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "VisorTableAttribute" || a.AttributeClass?.Name == "VisorTable");
            if (attr == null) return false;
            sqlTypeName = attr.ConstructorArguments[0].Value?.ToString();
            return true;
        }

        private bool IsScalarType(ITypeSymbol type)
        {
            return type.SpecialType != SpecialType.None
                   || type.Name == "Guid"
                   || type.Name == "DateTime"
                   || type.Name == "DateTimeOffset"
                   || type.Name == "TimeSpan"
                   || type.Name == "Decimal";
        }

        private static bool IsCandidate(SyntaxNode node) => node is InterfaceDeclarationSyntax i && i.AttributeLists.Count > 0;

        private static INamedTypeSymbol? GetVisorInterface(GeneratorSyntaxContext context)
        {
            var interfaceDeclaration = (InterfaceDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(interfaceDeclaration) as INamedTypeSymbol;
            if (symbol == null) return null;
            return symbol.GetAttributes().Any(ad => ad.AttributeClass?.Name == "VisorAttribute" || ad.AttributeClass?.Name == "Visor") ? symbol : null;
        }
    }
}