using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visor.Generators
{
    [Generator]
    public class BootstrapperGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var provider = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsCandidate(node),
                    transform: (ctx, _) => GetVisorTableSymbol(ctx)
                )
                .Where(m => m != null)
                .Collect();

            context.RegisterSourceOutput(provider, (spc, symbols) =>
            {
                if (symbols.IsDefaultOrEmpty) return;

                var sb = new StringBuilder();

                sb.AppendLine("// <auto-generated/>");
                // Добавляем условие компиляции, чтобы код компилировался только если есть Npgsql
                sb.AppendLine("#if NET6_0_OR_GREATER"); 
                sb.AppendLine("using Npgsql;");
                sb.AppendLine("namespace Visor.PostgreSql");
                sb.AppendLine("{");
                sb.AppendLine("    public static class VisorBootstrapper");
                sb.AppendLine("    {");
                sb.AppendLine("        public static NpgsqlDataSourceBuilder UseVisor(this NpgsqlDataSourceBuilder builder)");
                sb.AppendLine("        {");

                var processedTypes = new System.Collections.Generic.HashSet<string>();

                foreach (var symbol in symbols)
                {
                    if (symbol == null) continue;
                    
                    var fullTypeName = symbol.ToDisplayString();
                    if (processedTypes.Contains(fullTypeName)) continue;
                    processedTypes.Add(fullTypeName);

                    var attr = symbol.GetAttributes().FirstOrDefault(a => 
                        a.AttributeClass?.Name == "VisorTableAttribute" || 
                        a.AttributeClass?.Name == "VisorTable");
                    
                    if (attr == null) continue;

                    var pgTypeName = attr.ConstructorArguments.FirstOrDefault().Value?.ToString();

                    if (!string.IsNullOrEmpty(pgTypeName))
                    {
                        // Просто регистрируем тип. Npgsql сам разберется с полями.
                        sb.Append("            builder.MapComposite<");
                        sb.Append(fullTypeName);
                        sb.Append(">(\"");
                        sb.Append(pgTypeName);
                        sb.AppendLine("\");");
                    }
                }

                sb.AppendLine("            return builder;");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
                sb.AppendLine("}");
                sb.AppendLine("#endif"); // Конец условия

                spc.AddSource("VisorBootstrapper.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        }

        private static bool IsCandidate(SyntaxNode node) => (node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0) || (node is StructDeclarationSyntax s && s.AttributeLists.Count > 0);

        private static INamedTypeSymbol? GetVisorTableSymbol(GeneratorSyntaxContext context)
        {
            var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node) as INamedTypeSymbol;
            if (symbol == null) return null;
            return symbol.GetAttributes().Any(ad => ad.AttributeClass?.Name == "VisorTableAttribute" || ad.AttributeClass?.Name == "VisorTable") ? symbol : null;
        }
    }
}