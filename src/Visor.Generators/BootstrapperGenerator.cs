using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Visor.Generators;

[Generator]
public class BootstrapperGenerator : IIncrementalGenerator
{
    private const string VisorTableAttribute = nameof(VisorTableAttribute);
    private const string VisorTableShortAttribute = "VisorTable";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsCandidate(node),
                transform: (generatorSyntaxContext, _) => GetVisorTableSymbol(generatorSyntaxContext)
            )
            .Where(symbol => symbol is not null)
            .Collect();

        context.RegisterSourceOutput(provider, (sourceProductionContext, symbols) =>
        {
            if (symbols.IsDefaultOrEmpty)
            {
                return;
            }

            var mappingsBuilder = new StringBuilder();
            var processedTypes = new HashSet<string>();

            foreach (var symbol in symbols)
            {
                if (symbol is null)
                {
                    continue;
                }

                var fullTypeName = symbol.ToDisplayString();
                if (!processedTypes.Add(fullTypeName))
                {
                    continue;
                }

                var attribute = symbol.GetAttributes().FirstOrDefault(a =>
                    a.AttributeClass?.Name is VisorTableAttribute or VisorTableShortAttribute);

                if (attribute is null)
                {
                    continue;
                }

                var pgTypeName = attribute.ConstructorArguments.FirstOrDefault().Value?.ToString();

                if (!string.IsNullOrEmpty(pgTypeName))
                {
                    // Register the composite type. Npgsql handles field mapping automatically.
                    mappingsBuilder.AppendLine($"            builder.MapComposite<{fullTypeName}>(\"{pgTypeName}\");");
                }
            }

            var source = GenerateSource(mappingsBuilder.ToString());
            sourceProductionContext.AddSource("VisorBootstrapper.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private string GenerateSource(string mappings)
    {
        // Using Raw String Literals for clean, readable template generation
        return $$"""
            // <auto-generated/>
            #if NET6_0_OR_GREATER
            using Npgsql;

            namespace Visor.PostgreSql
            {
                public static class VisorBootstrapper
                {
                    public static NpgsqlDataSourceBuilder UseVisor(this NpgsqlDataSourceBuilder builder)
                    {
            {{mappings}}
                        return builder;
                    }
                }
            }
            #endif
            """;
    }

    private static bool IsCandidate(SyntaxNode node) 
        => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 } 
        or StructDeclarationSyntax { AttributeLists.Count: > 0 };

    private static INamedTypeSymbol? GetVisorTableSymbol(GeneratorSyntaxContext context)
    {
        if (context.SemanticModel.GetDeclaredSymbol(context.Node) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        return symbol.GetAttributes()
            .Any(ad => ad.AttributeClass?.Name is VisorTableAttribute or VisorTableShortAttribute)
            ? symbol
            : null;
    }
}